DictaMandamus is a simple script for handling a simple organizational problem on unix systems.

The basic action is that it takes a simple configuration files which maps one set of directories onto another set of directories.  Symbolic links and directories will be generated in the destionation directories to make these directories appear to be the union of the source directories.

The problem that this was designed to solve is a contradiction in my organizational system for Unix libraries which are compiled from source.  When a program is installed from a tarball, it installs files across several destination directories, usually bin, src and include.  Typically, one installs such libraries into /usr/lib, /usr/local/lib or /opt/lib, where they can be easily accessed.  However, doing so can turn these standard directories into a terrible mess, in fact they already do by default, just look in /usr/lib on any unix system, and you will see it is impossible to tell at a glance which files belong to which libraries.  Thats fine for the computer, but I am a feeble, type A human, I need order!

Things would of course be neater if the libraries all resided in isolated, quarantined directories.  This would also allow many libraries to have multiple installed versions, and would allow for testing of new libraries without forcing them on all system users before the admin has been able to verify them.

However, this is also a problem, because we want the files to all be piled together into one place for the linkers and shells to access them.  The two requirements seem to be at odds with eachother.

There is, however, a way around this: symbolic links.  My system instead is to build each library in an isolated directory deep in a "system" directory, where things reside and live until they are ready for the light of day.  Then I add them to a directory mapping config file (yaml) which specifies how to map the "installed" files in the hidden system directory to the real system wide paths.   DictaMandamus can then be run on this config file, which will verify all existing symbolic links, update changed ones, and generate new ones as is needed.  This way the system wide directories appear to be the jumbled mess of libraries, headers and executables that Unix demands, but the backend system is a neatly organized system worthy of a 1950s suburb.

The author notes that this system is of course imperfect, it is better to use a package management system.  After all, that is why we all use Ubuntu, right? However, this is not always an availible option.  Additionally, some libraries compile their paths into the code at configure/build time, meaning the hidden system directory will still be internally referenced in some instances, instead of the more obvious unix standard location, which feels cludgy and wrong, but doesn't actually matter in practice.  And of course, just installing things into the system wide directories and not worrying about it is perfectly valid, as it has been standard practice for decades, so this really is for the monk-like type A, crazy weird admind like myself.
